= Bitemporality

== Why?
// Rationale?

One inherent question of using a temporal database, is how to model
time. A baseline notion of time that is always available is
*transaction-time*; the point at which data is transacted into the
database. Bitemporality comes in when we also need the concept of
*valid-time*.

.Time Axes
[#table-conversion%header,cols="d,d"]
|===
|Time|Purpose
|`transaction-time`|Used for audit purposes, technical requirements such as event sourcing.
|`valid-time`|Used for querying data across time, historical analysis.
|===

*transaction-time* represents the point at which data arrives into the
database. This gives us an audit trail and we can use transaction-time
to see what the state of the database was at a particular point in
time. You cannot write a new transaction with a transaction-time that
is in the past. This forms the basis of an immutable data-model and an
event sourced architecture.

*valid-time* is an arbitrary time that can originate from an upstream
 system, or by default is set to transaction-time. Valid time is
 what users will typically use for query purposes.

****
Writes can be made in the past of valid-time. Users will normally
ask 'what is the value of this entity at valid-time?' regardless if
this history has been rewritten several times at multiple
transaction-times.

Only if you want to ensure consistent reads across nodes or to do
auditing queries, would you need to consider both transaction-time and
valid-time.
****

NOTE: transaction-time is simply _now_ for most normal queries.

NOTE: When writing data, in case there isn’t any specific
valid-time available, valid-time and transaction-time take the
same value.

NOTE: Queries can use both times to get consistent reads, as long as
the data hasn’t been evicted.

== Examples

=== Valid Time

In any situation where your database isn't the ultimate owner of the
data and where corrections to data can flow in from various sources,
and at various times, then *transaction-time* isn't always suitable
for historical queries.

Imagine you have a financial trading system and you want to perform
calculations based on the official 'end of day', that occurs each day
at 17:00 hours. Does all the data arrive into your database at exactly
17:00? Or does the data arrive in fact arrive from an upstream source,
and we have to allow for some data to arrive out of order, and some
might just arrive after 17:00?

This can often be the case with high throughput systems where there
are clusters of processing nodes, enriching the data before it gets to
our store.

In this example, we want our queries to include the straggling bits of
data for our calculation purposes, and this is where *valid-time*
comes in. When data arrives into our database, it can come with an
arbitrary time-stamp that we can use for querying purposes.

Therefore we're not completely dependent on transaction-time, and we
can tolerate data arriving out of order.

.Why Valid Time?
****
In a ecosystem of many systems, where one cannot control
the ultimate time line, or other systems abilities to write into the
past, one needs bitemporality to ensure evolving but consistent views
of the data.
****

=== Transaction Time

For audit reasons, we might wish to know with certainty the value of a
given entity-attribute at a given tx-instant. In this case, we want to
exclude the possibility of the valid past being amended, so we need a
pre-correction view of the data, relying on tx-instant.

To achieve this we will use an as-of using ts (valid-time) and tx-ts
(transaction-time).

== References

* https://en.wikipedia.org/wiki/Temporal_database[Temporal database]
* https://martinfowler.com/eaaDev/timeNarrative.html[Temporal Patterns]
* https://kx.com/blog/kx-insights-powering-business-decisions-bitemporal-data/[Kx Insights: Powering Business Decisions with Bitemporal Data]
