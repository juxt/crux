= Queries

[#intro]
== Introduction

Crux is a document database that provides you with a comprehensive means of traversing and querying across all of your documents and data without any need to define a schema ahead of time.
This is possible because Crux is "schemaless" and automatically indexes the top-level fields in all of your documents to support efficient ad-hoc joins and retrievals.
With these capabilities you can quickly build queries that match directly against the relations in your data without worrying too much about the shape of your documents or how that shape might change in future.

Crux is also a graph database.
The central characteristic of a graph database is that it can support arbitrary-depth graph queries (recursive traversals) very efficiently by default, without any need for schema-level optimisations.
Crux gives you the ability to construct graph queries via a Datalog query language and uses graph-friendly indexes to provide a powerful set of querying capabilities.
Additionally, when Crux's indexes are deployed directly alongside your application you are able to easily blend Datalog and code together to construct highly complex graph algorithms.

//This page walks through many of the more interesting queries that run as part of Crux's default test suite.
//See the https://github.com/juxt/crux/blob/master/crux-test/test/crux/query_test.clj[`Crux query test file`] for the full suite of query tests and how each test listed below runs in the wider context.

Extensible Data Notation (edn) is used as the data format for the public Crux APIs.
To gain an understanding of edn see xref:tutorials::essential-edn[Essential EDN for Crux].

Note that all Crux Datalog queries run using a point-in-time view of the database which means the query capabilities and patterns presented in this section are not aware of valid times or transaction times.

A Datalog query consists of a set of variables and a set of clauses. The result
of running a query is a result set of the possible combinations of values that
satisfy all of the clauses at the same time. These combinations of values are
referred to as "tuples".

The possible values within the result tuples are derived from your database of
documents. The documents themselves are represented in the database indexes as
"entity–attribute–value" (EAV) facts. For example, a single document
`{:crux.db/id :myid :color "blue" :age 12}` is transformed into two facts
`[[:myid :color "blue"][:myid :age 12]]`.

In the most basic case, a Datalog query works by searching for "subgraphs" in
the database that match the pattern defined by the clauses. The values within
these subgraphs are then returned according to the list of return variables
requested in the `:find` vector within the query.

[#anatomy]
== Query Anatomy

A query in Crux is performed by calling `crux/q` on a Crux database snapshot with a quoted map and, optionally, additional arguments.

[source,clojure]
----
(crux/q
   (crux/db node) <1>
   '{:find [p1]
     :where [[p1 :name n]
             [p1 :last-name n]
             [p1 :name name]]
     :in [name]}
    "Smith")
----
<1> Usually, the snapshot view comes from calling `crux/db` on a Crux node

The query map accepts the following Keywords

.Query Keys
[cols="3,3,8,^2"]
|===
|Key|Type|Purpose|Required?

|<<#find,`:find`>>|Vector|Specify values to be returned|✓
|<<#where,`:where`>>|Vector|Restrict the results of the query|✓
|<<#in,`:in`>>|Vector|Specify external arguments|
|<<#ordering-and-pagination,`:order-by`>>|Vector|Control the result order|
|<<#ordering-and-pagination,`:limit`>>|Int|Specify how many results to return|
|<<#ordering-and-pagination,`:offset`>>|Int|Specify how many results to discard|
|<<#rules,`:rules`>>|Vector|Define powerful statements for use in `:where` clauses|
|<<#timeout,`:timeout`>>|Int|Specify maximum query run time in ms
|<<#full-results,`:full-results?`>>|Boolean|Specify whether to return full documents
|===

[#find]
== Find

The find clause of a query specifies what values to be returned. These will be returned as a list.

[#find-logic-variable]
=== Logic Variable

You can directly specify a logic variable from your query. The following will return all last names.

[source,clojure]
----
'{:find [n]
  :where [p :last-name n]}
----

[#find-aggregate]
=== Aggregates

You can specify an aggregate function to apply to at most one logic variable.

.Built-in Aggregate Functions
[cols="3,.^8"]
|===
|Usage|Description
|`(sum ?lvar)`| Accumulates as a single value via the Clojure https://clojuredocs.org/clojure.core/+[`&#43;`] function
|`(min ?lvar)` .2+| Return a single value via the Clojure https://clojuredocs.org/clojure.core/compare[`compare`] function which may operates on many types (integers, strings, collections etc.)
|`(max ?lvar)`
|`(count ?lvar)`| Return a single count of all values including any duplicates
|`(avg ?lvar)`| Return a single value equivalent to `sum / count`
|`(median ?lvar)` .3+| Return a single value corresponding to the statistical definition
|`(variance ?lvar)`
|`(stddev ?lvar)`
|`(rand N ?lvar)`| Return a vector of exactly N values, where some values may be duplicates if N is larger than the range
|`(sample N ?lvar)`| Return a vector of at-most N distinct values
|`(distinct ?lvar)`| Return a set of distinct values
|===

For example, to find the average `:age` field of all entities, you can do the following:
[source,clojure]
----
'{:find [(avg a)]
  :where [[p :age a]]}
----

Note there is always implicit grouping across aggregates due to how Crux performs the aggregation lazily _before_ turning the result tuples into a set.

User-defined aggregates are supported by adding a new method (via Clojure `defmethod`) for `crux.query/aggregate`. For example:

[source,clojure]
----
(defmethod crux.query/aggregate 'sort-reverse [_]
  (fn
    ([] [])
    ([acc] (vec (reverse (sort acc))))
    ([acc x] (conj acc x))))
----

[#eql-projection]
=== EQL Projection

// TODO: Not rewriting as this is being actively worked on and changed

*ALPHA* - subject to change without warning between releases.

Crux queries support a 'projection' syntax, allowing you to decouple specifying which entities you want from what data you'd like about those entities in your queries.
Crux's support is based on the excellent https://edn-query-language.org/eql/1.0.0/what-is-eql.html[EDN Query Language (EQL)^] library.

To specify what data you'd like about each entity, include a `(eql/project ?logic-var projection-spec)` entry in the `:find` clause of your query:

[source,clojure]
----
include::example$src/docs/examples.clj[tags=eql-query-1]
include::example$src/docs/examples.clj[tags=eql-query-1-r]

include::example$src/docs/examples.clj[tags=eql-query-2]
include::example$src/docs/examples.clj[tags=eql-query-2-r]
----

We can navigate to other entities (and hence build up nested results) using 'joins'.
Joins are specified in `{}` braces in the projection-spec - each one maps one join key to its nested spec:

[source,clojure]
----
include::example$src/docs/examples.clj[tags=eql-query-3]
include::example$src/docs/examples.clj[tags=eql-query-3-r]

include::example$src/docs/examples.clj[tags=eql-query-4]
include::example$src/docs/examples.clj[tags=eql-query-4-r]
----

We can also navigate in the reverse direction, looking for entities that refer to this one, by prepending `_` to the attribute name:

[source,clojure]
----
include::example$src/docs/examples.clj[tags=eql-query-5]
include::example$src/docs/examples.clj[tags=eql-query-5-r]
----

To rename attributes in the result, wrap the attribute in `(:source-attribute {:as :output-name})`:

[source,clojure]
----
{:find [(eql/project ?profession [:profession/name {(:user/_profession {:as :users}) [:user/id :user/name]}])]
 :where [[?profession :profession/name]]}

;; => [{:profession/name "Doctor",
;;      :users [{:user/id 1, :user/name "Ivan"},
;;              {:user/id 3, :user/name "Petr"}]},
;;     {:profession/name "Lawyer",
;;      :users [{:user/id 2, :user/name "Sergei"}]}]
----

You can quickly grab the whole document by specifying `*` in the projection spec:

[source,clojure]
----
include::example$src/docs/examples.clj[tags=eql-query-6]
include::example$src/docs/examples.clj[tags=eql-query-6-r]
----

For full details on what's supported in the projection-spec, see the https://edn-query-language.org/eql/1.0.0/specification.html[EQL specification^]
// TODO temporarily feature flagging recursion until it passes Datascript tests, see #1220
Crux does not (yet) support recursive queries.

[#where]
== Where

The `:where` section of a query constrains the result set to match only entities (or subgraphs of interconnected entities) which satisfy all terms in the supplied vector.

.Valid Terms
[cols="1,4"]
|===
|Name|Description
|<<#term-triple, triple>>| Restrict using EAV facts.
|<<#term-not, not>>| Negatively restrict
|<<#term-not-join, not-join>>| Not statement with its own scope
|<<#term-or, or>>| Restrict on at least on matching term
|<<#term-or-join, or-join>>| Or statement with its own scope
|<<#term-range, range>>| Restrict with inequalities
|<<#term-rule, rule>>| Restrict with a self-defined rule
|<<#term-pred, pred>>| Restrict with any predicate
|===

[#term-triple]
=== Triple

A triple is a vector of a logic variable, a document key and (optionally) a value to match which can be a literal or another logic variable.

It restricts results by matching EAV facts

[source,clojure]
----
'{:find [p] <1>
  :where [[p :name]]}

'{:find [p] <2>
  :where [[p :name "Smith"]]}

'{:find [p] <3>
  :where [[q :name n]
          [p :name n]]}
----
<1> This matches all entities, `p`, which have a `:name` field.
<2> This matches all entities, `p`, which have a `:name` of `"Smith"`.
<3> This matches all entities, `p`, which have a `:name` which match the `:name` of `q`.

[#term-not]
=== Not

The `not` term rejects a graph if all the terms within it are true.

[source,clj]
----
'{:find [p]
  :where [[p :crux.db/id]
          (not [p :name "John"]
               [p :last-name "Smith"])]}
----

This will match any document which does not have a `:name` of "John" _and_ a `:last-name` of "Smith".

It will still return results for `{:name "Alice" :last-name "Smith"}` and `{:name "John" :last-name "Appleseed"}`

[#term-not-join]
=== Not Join

The `not-join` term allows you to restrict the possibilities for logic variables by asserting that there does not exist a match for a given sequence of terms.

You declare which logic variables from outside the `not-join` scope are to be used in the join.

Any other logic variables within the not-join are scoped only for the join.

[source,clj]
----
'{:find [p]
  :where [[p :crux.db/id]
          (not-join [p] <1>
                    [p :last-name n] <2>
                    [p :name n])]}
----
<1> Declaration of which logic variables need to unify with the rest of the query
<2> Terms

This will match any entity, `p`, which has different values for the `:name` and `:last-name` field.

Importantly, the logic variable `n` is unbound outside the `not-join` term.

[#term-or]
=== Or

The `or` term accepts a graph if any of the terms within it are true.

[source,clj]
----
'{:find [p]
  :where [[p :crux.db/id]
          (or [p :name "John"]
              [p :name "Jane"])]}
----

This will match any document, `p`, which has a `:name` of "John" or "Jane"

[#term-or-join]
=== Or Join

The `or-join` term term allows you to restrict the possibilities for logic variables by asserting that there does not exist a match for a given sequence of terms.

You declare which logic variables from outside the `or-join` scope are to be used in the join.

Any other logic variables within the `or-join` are scoped only for the join.

[source,clj]
----
'{:find [p]
  :where [[p :crux.db/id]
          (or-join [p] <1>
                   (and [p :age a]
                        [(>= a 18)])
                   [p :name "John"])]}
----
<1> Declaration of which logic variables need to unify with the rest of the query

This will match any document, `p` which has an `:age` greater than or equal to 18 _or_ has a `:name` of "John".

Importantly, the logic variable `a` is unbound outside the `or-join` term.

[#term-range]
=== Range

The `range` term is a vector containing a list of a range operator and then two terms which can be logic variables or literals.

Allowed range operators are `<`, `<=`, `>=`, `>`, and `=`.

[source,clj]
----
'{:find [p] <1>
  :where [[p :age a]
          [(> a 18)]]}

'{:find [p] <2>
  :where [[p :age a]
          [q :age b]
          [(> a b)]]}

'{:find [p] <3>
  :where [[p :age a]
          [(> 18 a)]]}
----
<1> Finds any entity, `p`, with an `:age` which is greater than 18
<2> Finds any entity, `p`, with an `:age` which is greater than the `:age` of any entity
<3> Finds any entity, `p`, for which 18 is greater than `p`'s `:age`

[#term-rule]
=== Rules

<<#rules, See Rules>>

[#term-pred]
=== Predicates

A fully qualified Clojure function that returns a boolean can be used as a predicate term.

Predicate terms should be placed in a vector.

[source,clojure]
----
'{:find [p]
  :where [[p :age a]
          [(even? a)]]}
----

This matches all entities, `p` which have an even `:age`.

[#where-subqueries]
=== Subqueries

You can nest a subquery with a `:where` clause to bind the result for further use in the query.

==== Binding results as a scalar

[source,clj]
----
include::example$src/docs/examples.clj[tags=sub-query-example-1]
----

In the above query, we perform a subquery doing some arithmetic operations and returning the result - and bind the resulting relation as a scalar.

Result set:

[source,clj]
----
include::example$src/docs/examples.clj[tags=sub-query-example-1-r]
----

==== Binding results as a tuple

[source,clj]
----
include::example$src/docs/examples.clj[tags=sub-query-example-2]
----

Similar to the previous query, except we bind the resulting relation as a tuple.

Result set:

[source,clj]
----
include::example$src/docs/examples.clj[tags=sub-query-example-2-r]
----

In this example, we bind the results of a subquery and use them to return another result.

[source,clj]
----
include::example$src/docs/examples.clj[tags=sub-query-example-3]
----

Result set:

[source,clj]
----
include::example$src/docs/examples.clj[tags=sub-query-example-3-r]
----

[#in]
== In

Crux queries can take a set of additional arguments, binding them to variables under the `:in` key within the query.

`:in` supports various kinds of binding.

=== Scalar binding

[source,clj]
----
include::example$src/docs/examples.clj[tags=query-with-arguments1]
----

In the above query, we parameterize the `first-name` symbol, and pass in "Ivan" as our input, binding "Ivan" to `first-name` in the query.

Result Set:
[source,clj]
----
include::example$src/docs/examples.clj[tags=query-with-arguments1-r]
----

=== Collection binding

[source,clj]
----
include::example$src/docs/examples.clj[tags=query-with-arguments2]
----

This query shows binding to a collection of inputs - in this case, binding `first-name` to all of the different values in a collection of first-names.

Result Set:
[source,clj]
----
include::example$src/docs/examples.clj[tags=query-with-arguments2-r]
----

=== Tuple Binding

[source,clj]
----
include::example$src/docs/examples.clj[tags=query-with-arguments3]
----

In this query we are binding a set of variables to a single value each, passing in a collection as our input. In this case, we are passing a collection with a `first-name` followed by a `last-name`.

Result Set:
[source,clj]
----
include::example$src/docs/examples.clj[tags=query-with-arguments3-r]
----

=== Relation Binding

[source,clj]
----
include::example$src/docs/examples.clj[tags=query-with-arguments4]
----

Here we see how we can extend the parameterisation to match using multiple fields at once by passing and destructuring a relation containing multiple tuples.

Result Set:
[source,clj]
----
include::example$src/docs/examples.clj[tags=query-with-arguments4-r]
----

[#ordering-and-pagination]
== Ordering and Pagination

A Datalog query naturally returns a result set of tuples, however, the tuples
can also be consumed as a sequence and therefore you will always have an
implicit order available. Ordinarily this implicit order is not meaningful
because the join order and result order are unlikely to correlate.

The `:order-by` option is available for use in the query map to explicitly
control the result order.

[source,clj]
----
include::example$src/docs/examples.clj[tags=order-and-pagination-1]
----

Use of `:order-by` will typically require that results are fully-realised by
the query engine, however this happens transparently and it will automatically
spill to disk when sorting large result sets.

Basic `:offset` and `:limit` options are supported however typical pagination
use-cases will need a more comprehensive approach because `:offset` will
naively scroll through the initial result set each time.

[source,clj]
----
include::example$src/docs/examples.clj[tags=order-and-pagination-2]
----

Pagination relies on efficient retrieval of explicitly ordered documents and
this may be achieved using a user-defined attribute with values that get sorted
in the desired order. You can then use this attribute within your Datalog
queries to apply range filters using predicates.

[source,clj]
----
include::example$src/docs/examples.clj[tags=order-and-pagination-3]
----

Additionally, since Crux stores documents and can traverse arbitrary keys as
document references, you can model the ordering of document IDs with vector
values, e.g. `{:crux.db/id :zoe :closest-friends [:amy :ben :chris]}`

More powerful ordering and pagination features may be provided in the future.
Feel free to open an issue or get in touch to discuss your requirements.

[#rules]
== Rules

[source,clojure]
----
'{:find [p]
  :where [(adult? p)] <1>
  :rules [[(adult? p) <2>
           [p :age a] <3>
           [(>= a 18)]]]}
----
<1> Usage
<2> Rule signature
<3> Clauses

Rules are defined by a signature and then clauses as you would find in a `:where` statement.

They can be used as a shorthand for when you would otherwise be repeating the same restrictions in your `:where` statement.

The clauses in Rules can also use Rules. This allows for the recursive traversal of entities.

[source,clojure]
----
'{:find [p2]
 :where [[p1 :name "Smith"]
         (follow p1 p2)]
 :rules [[(follow p1 p2)
          [p1 :follow p2]]
         [(follow p1 p2)
          [p1 :follow t]
          (follow t p2)]]}
----

This example finds all entities that the entity with `:name` "Smith" is connected to via `:follow`, even if the connection is via intermediaries.

[#timeout]
== Timeout

`:timeout` sets the maximum run time of the query (in milliseconds).

If the query has not completed by this time, a `java.util.concurrent.TimeoutException` is thrown.

[#full-results]
== Full Results

Setting the `:full-results?` flag to true will cause logic variables in the `:find` clause to return the full document

[source,clojure]
----
(crux/submit-tx node [[:crux.tx/put {:crux.db/id :foo :bar :baz}]])

(crux/q <1>
  (crux/db node)
  '{:find [p]
    :where [[p :bar :baz]]})

(crux/q <2>
  (crux/db node)
  '{:find [p]
    :where [[p :bar :baz]]
    :full-results? true})
----
<1> returns `#{[:foo]}'
<2> returns `#{[{:crux.db/id :foo :bar :baz}]}'

[#valid-time-travel]
== Valid Time travel

When performing a query, `crux/q` is called on a database snapshot.

To query based on a different Valid Time, create this snapshot by specifying the desired Valid Time when we call `db` on the node.

[source,clj]
----
(crux/submit-tx
   node
   [[:crux.tx/put
     {:crux.db/id :malcolm :name "Malcolm" :last-name "Sparks"}
     #inst "1986-10-22"]
    [:crux.tx/put
     {:crux.db/id :malcolm :name "Malcolma" :last-name "Sparks"}
     #inst "1986-10-24"]])
----
* `:cardinality` (reverse joins) - by default, reverse joins put their values in a collection - for many-to-one/one-to-one reverse joins, specify `{:cardinality :one}` to return a single value.

Here, we have `put` different documents in Crux with different Valid Times.

[source,clj]
----
include::example$src/docs/examples.clj[tags=query-at-t-q1]
----

Here, we have defined a query, `q` to find all entities with a `:name` of "Malcolma" and `:last-name` of "Sparks"

We can run the query at different Valid Times as follows

[source,clj]
----
include::example$src/docs/examples.clj[tags=query-at-t-q1-q]

include::example$src/docs/examples.clj[tags=query-at-t-q2-q]
----

The first query will return an empty result set (`#{}`) because there isn't a document with the `:name` "Malcolma" valid at `#inst "1986-10-23"`

The second query will return `#{[:malcolm]}` because the document with `:name` "Malcolma" _is_ valid at the current time.
This will be the case so long as there are no newer versions (in the valid time axis) of the document that affect the current valid time version.

[#joins]
== Joins

=== Query: "Join across entities on a single attribute"

Given the following documents in the database
[source,clj]
----
include::example$src/docs/examples.clj[tags=join-d]
----

We can run a query to return a set of tuples that satisfy the join on the attribute `:name`
[source,clj]
----
include::example$src/docs/examples.clj[tags=join-q]
----

Result Set:
[source,clj]
----
include::example$src/docs/examples.clj[tags=join-r]
----

Note that every person joins once, plus 2 more matches.

=== Query: "Join with two attributes, including a multi-valued attribute"

Given the following documents in the database
[source,clj]
----
include::example$src/docs/examples.clj[tags=join2-d]
----

We can run a query to return a set of entities that `:follows` the set of entities with the `:name` value of `"Ivan"`
[source,clj]
----
include::example$src/docs/examples.clj[tags=join2-q]
----

Result Set:
[source,clj]
----
include::example$src/docs/examples.clj[tags=join2-r]
----

Note that because Crux is schemaless there is no need to have elsewhere declared that the `:follows` attribute may take a value of edn type `set`.

[#streaming-queries]
== Streaming Queries

Query results can also be streamed, particularly for queries whose results may
not fit into memory. For these, we use `crux.api/open-q`, which returns a
`Closeable` sequence.

We'd recommend using `with-open` to ensure that the sequence is closed properly.
Additionally, ensure that the sequence (as much of it as you need) is eagerly
consumed within the `with-open` block - attempting to use it outside (either
explicitly, or by accidentally returning a lazy sequence from the `with-open`
block) will result in undefined behaviour.

[source,clj,indent=0]
----
include::example$src/docs/examples.clj[tags=streaming-query]
----

[#history-api]
== History API

[#history-full-document-history]
=== Full Entity History
Crux allows you to retrieve all versions of a given entity:
[source,clj]
----
include::example$src/docs/examples.clj[tags=history-full]
----

=== Retrieving previous documents
When retrieving the previous versions of an entity, you have the option to additionally return the documents associated with those versions (by using `:with-docs?` in the additional options map)
[source,clj]
----
include::example$src/docs/examples.clj[tags=history-with-docs]
----

[#history-document-history-range]
=== Document History Range
Retrievable entity versions can be bounded by four time coordinates:

* valid-time-start
* tx-time-start
* valid-time-end
* tx-time-end

All coordinates are inclusive. All coordinates can be null.
[source,clj]
----
include::example$src/docs/examples.clj[tags=history-range]
----

[#clojure-tips]
== Clojure Tips

=== Quoting

Logic variables used in queries must always be quoted in the `:find` and
`:where` clauses, which in the most minimal case could look like the following:

[source,clj]
----
(crux/q db
  {:find ['?e]
   :where [['?e :event/employee-code '?code]]}))
----

However it is often convenient to quote entire clauses or even the entire query
map rather than each individual use of every logic variable, for instance:

[source,clj]
----
(crux/q db
  '{:find [?e]
    :where [[?e :event/employee-code ?code]]}))
----

Confusion may arise when you later attempt to introduce references to Clojure
variables within your query map, such as when using `:args`. This can be
resolved by introducing more granular quoting for specific parts of the query
map:

[source,clj]
----
(let [my-code 101214]
  (crux/q db
    {:find '[?e]
     :where '[[?e :event/employee-code ?code]]
     :args [{'?code my-code}]}))
----

=== Maps and Vectors in data

Say you have a document like so and you want to add it to a Crux db:
[source,clj]
----
{:crux.db/id :me
 :list ["carrots" "peas" "shampoo"]
 :pockets {:left ["lint" "change"]
           :right ["phone"]}}
----

Crux breaks down vectors into individual components so the query engine is able
see all elements on the base level. As a result of this the query engine is not
required to traverse any structures or any other types of search algorithm
which would slow the query down. The same thing should apply for maps so
instead of doing `:pocket {:left thing :right thing}` you should put them under
a namespace, instead structuring the data as `:pocket/left thing :pocket/right
thing` to put the data all on the base level. Like so:

[source,clj]
----
(crux/submit-tx
  node
  [[:crux.tx/put
    {:crux.db/id :me
     :list ["carrots" "peas" "shampoo"]
     :pockets/left ["lint" "change"]
     :pockets/right ["phone"]}]
   [:crux.tx/put
    {:crux.db/id :you
     :list ["carrots" "tomatoes" "wig"]
     :pockets/left ["wallet" "watch"]
     :pockets/right ["spectacles"]}]])
----

To query inside these vectors the code would be:

[source,clj]
----
(crux/q (crux/db node) '{:find [e l]
                         :where [[e :list l]]
                         :args [{l "carrots"}]})
;; => #{[:you "carrots"] [:me "carrots"]}

(crux/q (crux/db node) '{:find [e p]
                         :where [[e :pockets/left p]]
                         :args [{p "watch"}]})
;; => #{[:you "watch"]}
----

Note that `l` and `p` is returned as a single element as Crux decomposes the
vector

[#datascript-differences]
== DataScript Differences

This list is not necessarily exhaustive and is based on the partial re-usage of
DataScript's query test suite within Crux's query tests.


Crux does not support:

- vars in the attribute position, such as `[e ?a "Ivan"]` or `[e _ "Ivan"]`

Crux does _not yet_ support:

- `ground`, `get-else`, `get-some`, `missing?`
- backref attribute syntax (i.e. `[?child :example/_child ?parent]`)

Note that many advanced query features can be achieved via custom predicate function calls since you can currently reference any fully qualified function that is loaded. In future, limitations on available functions may be introduced to enforce security restrictions for remote query execution.

Test queries from DataScript such as "Rule with branches" and "Mutually recursive rules" work correctly with Crux and demonstrate advanced query patterns. See the https://github.com/juxt/crux/blob/master/crux-test/test/crux/query_test.clj[Crux query tests] for details.
